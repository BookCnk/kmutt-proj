# Design: "Admissions Report Generator" (Client-Only Feature)

## 1. System Architecture

The architecture is 100% client-side. All logic resides and executes within the user's browser on a single Next.js page.

## 2. Component Structure

The feature will be built as a single-page application within `app/admin/export/report/page.tsx`.

- **`app/admin/export/report/page.tsx`**
  - This will be the main Client Component (`'use client'`).
  - It will manage the primary React state:
    - `const [csvData, setCsvData] = useState<any[] | null>(null);`
    - `const [structuredData, setStructuredData] = useState<Major[] | null>(null);`
  - It will render child components conditionally.

- **`components/admin/export/CsvUploader.tsx`**
  - Uses `papaparse` to read the uploaded CSV file.
  - On completion, it calls `setCsvData(results.data)`.

- **`components/admin/export/DataEditor.tsx`**
  - Receives `structuredData` and `setStructuredData` as props.
  - Renders the structured JSON into an editable form (e.g., using `react-json-editor-ajrm` or a custom form).
  - This is the "human manual type" interface. All edits directly update the `structuredData` state.

- **`components/admin/export/ReportPreview.tsx`**
  - Receives `structuredData` as a prop.
  - Renders the data into a high-fidelity HTML structure (wrapped in `<div id="report-preview">`) that visually mimics the final PDF.
  - This component is styled with standard Tailwind classes for the "on-screen" preview.

## 3. Client-Side Services

- **`lib/services/csvTransformService.ts`**
  - This is the **core logic** that replaces the AI. It will contain the programmatic transformation function.
  - `export function transformCsvData(csvRows: any[]): Major[] { ... }`
  - **Logic:**
    1.  Initialize an empty `Map<string, Major>` to store majors.
    2.  Loop through each `row` in the `csvRows` array.
    3.  Create a unique `majorId` (e.g., from `row["Major (Admission Major Mapping)"]`).
    4.  If `majorsMap.has(majorId)` is false, create a new `Major` object from the row (getting `faculty`, `fee`, `admitCount`, etc.) and add it to the map.
    5.  Get the `major` object from the map.
    6.  Find or create the correct `qualification` object based on `row["Subject Group Map"]` (applicant type).
    7.  Check if `row["Name"]` is an English test (e.g., "TOEIC", "IELTS").
    8.  If it is, push the subject, condition, and score to the `qualification.englishTests` array.
    9.  If it's not, push it to the `qualification.requirements` array.
    10. After the loop, return `Array.from(majorsMap.values())`.

## 4. PDF Generation Strategy (`window.print()`)

- The final PDF is generated by the browser's native print engine.
- A "Generate PDF" button will call `window.print()`.
- A dedicated print stylesheet (`styles/print.css`) will be used to ensure high fidelity.

  ```css
  /* styles/print.css */

  /* When printing... */
  @media print {
    /* Hide all UI (sidebar, header, uploader, editor) */
    body * {
      visibility: hidden;
    }

    /* Show *only* the report preview and its contents */
    #report-preview,
    #report-preview * {
      visibility: visible;
    }

    /* Position the report to fill the printed page */
    #report-preview {
      position: absolute;
      left: 0;
      top: 0;
      margin: 0;
      border: none;
      width: 100%;
      height: auto;
    }

    /* Force a new page after each major's section */
    .report-major-section {
      page-break-after: always;
    }

    /* Prevent tables from breaking across pages awkwardly */
    table {
      page-break-inside: auto;
    }
    tr {
      page-break-inside: avoid;
    }
  }
  ```
